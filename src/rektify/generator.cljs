(ns rektify.generator
  "
  # Generator creation, manipulation and generation for Rektify.

  A generator is a Clojure map which contains a descriptor with lifecycle
  functions, and a map of properties.

  The generator map has the following keys in it:

  ```clojure
  {:rektify/type ::generator   ;; internal identifier
   ::desc {}                   ;; descriptor with lifecycle functions
   ::props {}}                 ;; generator's properties
  ```

  A generator's descriptor has the following keys defining lifecycle functions
  with the documented signatures:

  * `init`: `[props]`: (optional) Called when a new generator is
    about to be generated for the first time.

  * `generate`: `[props local-state]`: Generate a v-tree which will be
    later reified/rektified during a generation pass. The v-tree can also
    contain other generators.

  * (**`regenerate?`** `[props local-state]`): _(optional)_ Predicate
    which determines if a generator should be regenerated during the next
    generation phase. A generator will always generate once but after that
    this predicate will determine if regeneration is needed. If this function
    is not defined then a generator will always be generated.

  * `destroy`: `[props local-state]`: (optional) Clean up any resources which
    need some kind of manual deallocation. This is called before any objects
    generated by this generator are destroyed. Object destruction happens
    during rektification. Also, local-state manipulation functions are not
    available during destruction.

  During execution of a generator's lifecycle functions the current local-state
  will be passed in as an immutable map. If the generator needs to mutate its
  state the state manipulation functions can be used to do so. The results
  of all local-state manipulation functions will be passed in during the next
  generation.
  "
  (:require [clojure.zip :as z]
            [rektify.virtual-tree :as vt]
            [clojure.set :as set]
            [clojure.string :as string]))


;; XXX: remove all metadata and just use regular map keys for everything
;; XXX: value equivalence is never needed for generation


(def required-lifecycle-fns
  "Required generator lifecycle functions"
  #{:generate})


(defn valid-desc?
  "Is `gen-desc` a valid generator descriptor?"
  [gen-desc]
  (and (map? gen-desc)
       (fn? (:generate gen-desc))))


(defn invalid-gen-desc-msg
  "Return an error message describing why a generator descriptor is invalid"
  [gen-desc]
  (if (not (map? gen-desc))
    "gen-desc must be a map of lifecycle functions"
    (let [missing-required (set/difference required-lifecycle-fns (keys gen-desc))]
      (cond
        missing-required
        (str "gen-desc is missing required lifecycle functions: "
             (string/join ", " missing-required))))))


(defn generator
  "Return a new generator map, given a generator descriptor and optionally
   a properties map"
  ([gen-desc]
   (generator gen-desc {}))
  ([gen-desc props]
   (assert (valid-desc? gen-desc) (invalid-gen-desc-msg gen-desc))
   (assert (map? props) "props must be a map")
   ;; XXX: validate the descriptor and ensure there is a generate key w/func value
   {:rektify/type ::generator
    ::desc gen-desc
    ::props props}))


(defn generator?
  "Is a valid generator map?"
  [gen]
  (= ::generator (:rektify/type gen)))


(defn valid-generator?
  "Is `gen` a generator with valid properties?"
  [gen]
  (and (map? gen)
       (generator? gen)
       (and (= ::generator (:rektify/type gen))
            (map? (::desc gen))
            (map? (::props gen)))))


(defn props
  "Return the generator's properties"
  [gen]
  (::props gen))


(defn desc
  "Return the generator's descriptor"
  [gen]
  (::desc gen))


(defn update-props
  "Returns a generator with its properties update to the `new-props` map"
  [gen new-props]
  (assert (generator? gen))
  (assert (map? new-props))
  (assoc gen ::props new-props))


(defn same-types?
  "Are the generators the same type?"
  [gen1 gen2]
  (= (::desc gen1) (::desc gen2)))


(defn generated?
  "Has the generator generated a v-tree?"
  [gen]
  (contains? gen ::v-tree))


(defn state
  "Get the generator's state map"
  [gen]
  (::state gen))


(defn gen-children
  "Get a generated generator's children."
  [gen]
  (::gen-children gen))


(defn ^:private update-gen-children
  "Add or replace a list of generator children for a generator."
  [gen gen-children]
  (assoc gen ::gen-children gen-children))


(defn gen-zip
  "Creates a zipper over a generator and its children."
  [gen]
  (z/zipper generator? gen-children update-gen-children gen))


(defn v-tree
  "Get a generator's v-tree"
  [gen]
  (::v-tree gen))


(defn rekt-v-tree
  "Return the rektified v-tree from the root generator."
  [gen]
  (::rekt-v-tree gen))


(defn obj&
  "Get the object at the head of the generator's rektified v-tree"
  [gen]
  (vt/obj& (rekt-v-tree gen)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Generator state manipulation

(def ^:dynamic *active-gen-state*
  "State of the current generator being generated wrapped in an atom. This
  allows for state mutation inside of lifecycle functions, but the mutated
  state will not be passed into the generator until the next generation cycle."
  (atom nil :validator #(throw (js/Error. "Generator state can not be modified outside of a lifecycle function."))))


(defn swap-state!
  "Like the Clojure `swap!` function, executes a function which will be provided
  the current generator state and return a new state."
  [f & args]
  (swap! *active-gen-state* #(apply f % args))
  nil)


(defn reset-state!
  "Reset the generator's state to the provided value."
  [new-state]
  (reset! *active-gen-state* new-state)
  nil)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Generation functionality

(defn ^:private call-generate
  [gen cur-state]
  (let [generate-fn (:generate (desc gen))]
    (generate-fn (props gen) cur-state)))


(defn ^:private call-destroy!
  [gen]
  ;; XXX: recursively destroy child generators, need to refactor so that *active-gen-state* is only bound once during tree walk
  (binding [*active-gen-state* (atom nil :validator #(throw (js/Error. "Generator state can not be modified while being destroyed")))]
    (when-let [destroy-fn (:destroy (desc gen))]
      (destroy-fn (props gen) (state gen)))
    nil))


(defn ^:private call-init
  [gen]
  (when-let [init-fn (:init (desc gen))]
    (init-fn (props gen)))
  nil)


(defn ^:private regenerate?
  "Does this generator want to be regenerated? If no :regenerate? lifecycle
  function exists, just return `true`."
  [gen]
  (assert (generated? gen) "generate must have been previously generated")
  (if-let [regenerate?-fn (:regenerate? (desc gen))]
    (regenerate?-fn (props gen) (state gen))
    true))


(defn assemble-generated-v-tree
  "Walk the generator and its children and return its full v-tree"
  [gen]
  ;; XXX: Ignore children for now and just return head v-tree
  (v-tree gen))


(defn ^:private init-and-generate
  [gen]
  (assert (not (generated? gen)) "gen must not be generated when attempting to generate")
  (binding [*active-gen-state* (atom nil)]
    (call-init gen)
    (let [v-tree (call-generate gen @*active-gen-state*)]
      (merge gen {::state @*active-gen-state*
                  ::v-tree v-tree}))))


(defn ^:private regenerate
  [gen]
  (assert (valid-generator? gen) "gen is not a valid generator")
  (assert (generated? gen) "gen must be previously generated")
  ;; if the generator doesn't want to be regenerated just return it
  (if (not (regenerate? gen))
    gen
    (let [cur-state (state gen)]
      (binding [*active-gen-state* (atom cur-state)]
        (let [new-v-tree (call-generate gen cur-state)]
          (merge gen {::state @*active-gen-state*
                      ::v-tree new-v-tree}))))))


(defn ^:private compare-and-generate
  [gen prev-gen]
  (cond
    (nil? prev-gen)
    (if (generated? gen)
      (regenerate gen)
      (init-and-generate gen))

    (same-types? gen prev-gen)
    (regenerate (merge prev-gen gen))

    (not (same-types? gen prev-gen))
    (do (call-destroy! prev-gen)
        (init-and-generate gen))

    :default
    (throw (js/Error. "could not find a method to compare-and-generate"))))


(defn generate
  ([gen] (generate gen nil))
  ([gen prev-gen]
   (assert (valid-generator? gen) "gen is not a valid generator")
   (assert (or (nil? prev-gen) (valid-generator? prev-gen)) "prev-gen is not a valid generator")
   (assert (or (nil? prev-gen) (and (not (generated? gen)) (generated? prev-gen))) "when prev-gen is provided it must be generated and gen must not be generated")
   (let [prev-v-tree (if (generated? prev-gen)
                       (rekt-v-tree prev-gen)
                       (rekt-v-tree gen))
         generated-gen (compare-and-generate gen prev-gen)
         new-v-tree (assemble-generated-v-tree generated-gen)]
     ;; Rektify the new v-tree and assoc with generated gen
     (assoc generated-gen ::rekt-v-tree (vt/rektify new-v-tree prev-v-tree)))))


